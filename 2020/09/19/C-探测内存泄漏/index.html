<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="C++探测内存泄漏"><meta name="keywords" content="C++,MemoryLeak"><meta name="author" content="Hongyi Guo"><meta name="copyright" content="Hongyi Guo"><title>C++探测内存泄漏 | Hongyi's</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?77a8c2d0f4e8f862b652458768e3fc6a";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text"> 简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用crt中的_crtdumpmemoryleaks探测内存泄漏"><span class="toc-number">2.</span> <span class="toc-text"> 使用CRT中的_CrtDumpMemoryLeaks探测内存泄漏</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用vldvisual-leak-detector探测内存泄漏"><span class="toc-number">3.</span> <span class="toc-text"> 使用VLD（Visual Leak Detector）探测内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#安装vld"><span class="toc-number">3.1.</span> <span class="toc-text"> 安装VLD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在vs2019中编译vld"><span class="toc-number">3.2.</span> <span class="toc-text"> 在VS2019中编译VLD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在vs2019中使用vld"><span class="toc-number">3.3.</span> <span class="toc-text"> 在VS2019中使用VLD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用vld中可能会遇到的问题"><span class="toc-number">3.4.</span> <span class="toc-text"> 使用VLD中可能会遇到的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#问题一不显示文件及行号"><span class="toc-number">3.4.1.</span> <span class="toc-text"> 问题一：不显示文件及行号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题二未生成内存泄漏的日志"><span class="toc-number">3.4.2.</span> <span class="toc-text"> 问题二：未生成内存泄漏的日志</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://guohy-1258918948.cos.ap-shanghai.myqcloud.com/avatar.jpg"></div><div class="author-info__name text-center">Hongyi Guo</div><div class="author-info__description text-center">Nothing is impossible to a willing heart.</div><div class="follow-button"><a href="https://github.com/GuohyCoding">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">13</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">10</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://guohy-1258918948.cos.ap-shanghai.myqcloud.com/59f7d76d99a79.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Hongyi's</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">C++探测内存泄漏</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-19</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Technology/">Technology</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">1.7k</span><span class="post-meta__separator">|</span><span>Reading time: 6 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<p>由于C++没有垃圾回收机制，在写C++代码的时候，很重要的一点就是要小心内存的使用，虽然大家都会格外注意new、delete和malloc、free要成对出现，delete完指针还要置为空，但是不免在大型项目中会遗忘，或者是调用第三方API内部有new却忘了释放。在Linux gcc下可以使用Valgrind工具来探测泄漏，本文重点介绍下在windows下如何探测内存泄漏。</p>
<a id="more"></a>
<h1 id="使用crt中的_crtdumpmemoryleaks探测内存泄漏"><a class="markdownIt-Anchor" href="#使用crt中的_crtdumpmemoryleaks探测内存泄漏"></a> 使用CRT中的_CrtDumpMemoryLeaks探测内存泄漏</h1>
<p>C++程序的内存分配要通过CRT（C Runtime Library）在运行时动态的分配，通过比较在分配内存和释放内存时的记录数据就可确定是否发生了内存泄漏，Visual Studio为Windows平台提供了检测和识别内存泄漏的工具_CrtDumpMemoryLeaks</p>
<p>在程序开头加上以下语句，注意include的顺序不要改变</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRTDBG_MAP_ALLOC </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;crtdbg.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>在程序的出口处加上_CrtDumpMemoryLeaks()，在程序运行结束后会在输出窗口显示内存泄漏信息，注意__CrtDumpMemoryLeaks只有在debug模式下才会输出内存泄漏信息，下面以一个例子来展示一下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRTDBG_MAP_ALLOC </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;crtdbg.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>* c = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">20</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));   <span class="comment">// malloc</span></span><br><span class="line">	_CrtDumpMemoryLeaks();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在输出窗口可以看到内存泄漏的信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Detected memory leaks!</span><br><span class="line">Dumping objects -&gt;</span><br><span class="line">C:\Users\Administrator\Desktop\Test\MemoryLeak\MemoryLeak\MemoryLeak.cpp(<span class="number">13</span>) : &#123;<span class="number">79</span>&#125; normal block at <span class="number">0x00766680</span>, <span class="number">20</span> bytes <span class="keyword">long</span>.</span><br><span class="line"> Data: &lt;                &gt; CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD </span><br><span class="line">Object dump complete.</span><br></pre></td></tr></table></figure>
<p>_CrtDumpMemoryLeaks()会记录下内存泄漏发生的文件及位置，还能告诉你有多少比特的内存被泄漏了，但是实际使用起来呢还是不太方便，这时候免费专业的VLD（Visual Leak Detector）就闪亮登场了。</p>
<h1 id="使用vldvisual-leak-detector探测内存泄漏"><a class="markdownIt-Anchor" href="#使用vldvisual-leak-detector探测内存泄漏"></a> 使用VLD（Visual Leak Detector）探测内存泄漏</h1>
<p>VLD是一个在VS中很好的探测内存泄漏的工具，官方对其的描述为</p>
<ul>
<li>为每个泄漏块提供完整的堆栈跟踪，包括源文件和行号信息（如果可用）</li>
<li>检测大多数（如果不是全部）进程内存泄漏类型，包括基于COM的泄漏和纯Win32堆泄漏</li>
<li>可以从泄漏检测中排除所选模块（DLL或甚至主EXE）</li>
<li>提供泄漏块的完整数据转储（十六进制和ASCII）</li>
<li>可自定义的内存泄漏报告：可以保存到文件或发送到调试器，并且可以包含可变级别的详细信息</li>
</ul>
<h2 id="安装vld"><a class="markdownIt-Anchor" href="#安装vld"></a> 安装VLD</h2>
<ol>
<li>
<p>进入VLD的主页：<a href="http://vld.codeplex.com/" target="_blank" rel="noopener">http://vld.codeplex.com/</a></p>
</li>
<li>
<p>进入主页后，点击【download】按钮进行下载 VLD 最新版本</p>
</li>
<li>
<p>如果VS是VS2015及以下版本，就可以直接使用VLD了，需要配置以下信息（根据VLD的安装目录进行调整）</p>
</li>
</ol>
<ul>
<li>C/C++ -&gt; 常规 -&gt; 附加包含目录：D:\Program Files\Visual Leak Detector\include</li>
<li>链接 -&gt; 常规 -&gt; 附加库目录：D:\Program Files\Visual Leak Detector\lib\Win32</li>
</ul>
<p>在cpp文件开头引用#include “vld.h”，如果有预编译头文件stdafx.h，则需要放到stdafx.h之后</p>
<p>如果VS是VS2015以上版本，安装完VLD会将VLD的配置文件vld.ini加到环境变量中，我以VS2019为例，介绍下VLD在VS高版本下的编译和使用</p>
<h2 id="在vs2019中编译vld"><a class="markdownIt-Anchor" href="#在vs2019中编译vld"></a> 在VS2019中编译VLD</h2>
<p>为了能够在VS2019中使用VLD，需要手动编译VLD的源码，首先下载VLD的源码：<a href="https://github.com/KindDragon/vld" target="_blank" rel="noopener">https://github.com/KindDragon/vld</a></p>
<p>用VS2019打开vld_vs14.sln工程，将除了VLD和Libs下的libformat项目以外的其他项目都暂时卸载掉，右键libformat项目属性菜单，将平台工具集和目标平台版本改为VS2019所支持的设置，我改的为v142和10.0</p>
<p>接下来进入vld.cpp，搜索#error Not supported VS，将以下三行代码注释掉后生成解决方案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _MSC_VER &gt; 1924</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> Not supported VS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>将vld/src/bin/Win32/Release-v142（根据你的编译设置）中的vld.lib和vld_x86.dll加进你需要探测内存泄漏的项目中，将vld源码中的vld.h和vld_def.h复制到项目中，将vld源码中setup下dbghelp中的dbghelp.dll和Microsoft.DTfW.DHL.manifest复制到项目运行目录下（debug文件下），添加好所有的头文件包含和lib包含就可以使用VLD了</p>
<h2 id="在vs2019中使用vld"><a class="markdownIt-Anchor" href="#在vs2019中使用vld"></a> 在VS2019中使用VLD</h2>
<p>在cpp文件开头引用#include “vld.h”，如果有预编译头文件stdafx.h，则需要放到stdafx.h之后，使用方法很简单，示例程序如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vld.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>* c = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">20</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));   <span class="comment">// malloc</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在输出窗口可以看到以下信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">WARNING: Visual Leak Detector detected memory leaks!</span><br><span class="line">---------- Block <span class="number">1</span> at <span class="number">0x00D58AF8</span>: <span class="number">20</span> bytes ----------</span><br><span class="line">  Leak Hash: <span class="number">0x801B9582</span>, Count: <span class="number">1</span>, Total <span class="number">20</span> bytes</span><br><span class="line">  Call Stack (TID 36480):</span><br><span class="line">    ucrtbased.dll!<span class="built_in">malloc</span>()</span><br><span class="line">    C:\Users\Administrator\Desktop\test\MemoryLeak\MemoryLeak\MemoryLeak.cpp (<span class="number">13</span>): MemoryLeak.exe!main() + <span class="number">0xA</span> bytes</span><br><span class="line">    D:\agent\_work\<span class="number">4</span>\s\src\vctools\crt\vcstartup\src\startup\exe_common.inl (<span class="number">78</span>): MemoryLeak.exe!invoke_main() + <span class="number">0x2D</span> bytes</span><br><span class="line">    D:\agent\_work\<span class="number">4</span>\s\src\vctools\crt\vcstartup\src\startup\exe_common.inl (<span class="number">288</span>): MemoryLeak.exe!__scrt_common_main_seh() + <span class="number">0x5</span> bytes</span><br><span class="line">    D:\agent\_work\<span class="number">4</span>\s\src\vctools\crt\vcstartup\src\startup\exe_common.inl (<span class="number">331</span>): MemoryLeak.exe!__scrt_common_main()</span><br><span class="line">    D:\agent\_work\<span class="number">4</span>\s\src\vctools\crt\vcstartup\src\startup\exe_main.cpp (<span class="number">17</span>): MemoryLeak.exe!mainCRTStartup()</span><br><span class="line">    KERNEL32.DLL!BaseThreadInitThunk() + <span class="number">0x19</span> bytes</span><br><span class="line">    ntdll.dll!RtlGetAppContainerNamedObjectPath() + <span class="number">0xE4</span> bytes</span><br><span class="line">    ntdll.dll!RtlGetAppContainerNamedObjectPath() + <span class="number">0xB4</span> bytes</span><br><span class="line">  Data:</span><br><span class="line">    CD CD CD CD    CD CD CD CD    CD CD CD CD    CD CD CD CD     췍췍췍췍췍췍췍췍</span><br><span class="line">    CD CD CD CD                                                  췍췍......</span><br><span class="line"></span><br><span class="line">Visual Leak Detector detected 1 memory leak (56 bytes).</span><br><span class="line">Largest number used: <span class="number">56</span> bytes.</span><br><span class="line">Total allocations: <span class="number">56</span> bytes.</span><br><span class="line">Visual Leak Detector is now exiting.</span><br></pre></td></tr></table></figure>
<p>相较于_CrtDumpMemoryLeaks()，VLD的输出信息更加友好，并且调用堆栈可以点击直接跳到内存泄漏的语句处，非常方便</p>
<h2 id="使用vld中可能会遇到的问题"><a class="markdownIt-Anchor" href="#使用vld中可能会遇到的问题"></a> 使用VLD中可能会遇到的问题</h2>
<h3 id="问题一不显示文件及行号"><a class="markdownIt-Anchor" href="#问题一不显示文件及行号"></a> 问题一：不显示文件及行号</h3>
<p>我在使用VLD的时候有时候Call Stack不显示具体的调用堆栈信息，这对探测内存泄漏位置造成了很大的困扰，相信很多小伙伴都遇到过，这种情况下主要是由于项目路径中存在中文，_CrtDumpMemoryLeaks()和VLD都默认编码格式为ascii，VLD可以通过修改vld.ini来解决这个问题</p>
<p>进入环境变量目录下的vld.ini文件，将ReportEncoding 设置为unicode</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; Sets the type of encoding to use for the generated memory leak report. This</span><br><span class="line">; option is really only useful in conjuction with sending the report to a file.</span><br><span class="line">; Sending a Unicode encoded report to the debugger is not useful because the</span><br><span class="line">; debugger cannot display Unicode characters. Using Unicode encoding might be</span><br><span class="line">; useful if the data contained in leaked blocks is likely to consist of Unicode</span><br><span class="line">; text.</span><br><span class="line">;</span><br><span class="line">;   Valid Values: ascii, unicode</span><br><span class="line">;   Default: ascii</span><br><span class="line">;</span><br><span class="line">ReportEncoding = ascii</span><br></pre></td></tr></table></figure>
<h3 id="问题二未生成内存泄漏的日志"><a class="markdownIt-Anchor" href="#问题二未生成内存泄漏的日志"></a> 问题二：未生成内存泄漏的日志</h3>
<p>如果想将内存泄露信息保存在日志文件中的话，则需要将vld.ini文件中ReportTo 设置为both，具体可以看前面的注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; Sets the report destination to either a file, the debugger, or both. If</span><br><span class="line">; reporting to file is enabled, the report is sent to the file specified by the</span><br><span class="line">; ReportFile option.</span><br><span class="line">;</span><br><span class="line">;   Valid Values: debugger, file, both</span><br><span class="line">;   Default: debugger</span><br><span class="line">;</span><br><span class="line">ReportTo = both</span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Hongyi Guo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://guohongyi.com/2020/09/19/C-探测内存泄漏/">https://guohongyi.com/2020/09/19/C-探测内存泄漏/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/MemoryLeak/">MemoryLeak</a></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="next-post pull-right"><a href="/2020/06/16/C-调用C-dll走过的坑/"><span>C#调用C++ DLL走过的坑</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'Rh8B8qrnJ3cukY5PM5TJziVq-gzGzoHsz',
  appKey:'zHaQG2PQjKnL9mXX2EAbKFDB',
  placeholder:'Please leave your footprints',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'5',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://guohy-1258918948.cos.ap-shanghai.myqcloud.com/59f7d76d99a79.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Hongyi Guo</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://guohongyi.com">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>